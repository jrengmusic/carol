# ARCHITECTURE-WRITER.md
## Instructions for Agents: How to Analyze and Document Architecture

**Purpose:** Step-by-step protocol for agents (ANALYST, INSPECTOR, CARETAKER, SURGEON) to write or update ARCHITECTURE.md from working codebase.

**For Agents:** Read this document when assigned architecture documentation tasks.

**Version:** 1.0

---

## Role Responsibilities

### Who Writes ARCHITECTURE.md?

**ANALYST:**
- Writes initial architecture sketch after SPEC is concrete
- Updates when SPEC changes significantly
- Documents new patterns after human approval

**INSPECTOR:**
- Updates after audit discovers new patterns
- Documents refactoring opportunities (human decides)
- Validates architecture matches codebase

**CARETAKER:**
- Updates when polishing introduces new patterns
- Documents wiring decisions made during implementation

**SURGEON:**
- Updates when surgical fix reveals new pattern
- Documents edge cases discovered during fix

**NEVER assume architecture. ALWAYS consult human if uncertain.**

---

## Critical Rules for Writing ARCHITECTURE.md

### Rule 0: Codebase is SSOT

**ARCHITECTURE.md captures what EXISTS in code, not what SHOULD exist.**

If you find mismatch:
1. Verify codebase is correct (check SPEC.md)
2. Update ARCHITECTURE.md to match codebase
3. Note discrepancy in session summary

**Never modify code to match documentation.**

---

## Role-Specific Instructions

### For ANALYST

**When you write ARCHITECTURE.md:**
1. Read SPEC.md completely
2. Identify module boundaries from spec
3. Sketch initial layer separation
4. Propose dependency graph
5. Document design decisions from SPEC
6. **STOP HERE** - Wait for human architect approval

**You write INITIAL architecture, not final.**

**Your output format:**
```markdown
# [PROJECT] - Architecture (DRAFT)

## Proposed Module Structure
[Your analysis]

## Proposed Layer Separation
[Your suggestions]

## Open Questions for Architect
- Should [module A] depend on [module B] or vice versa?
- Where should [responsibility X] live?
- Threading model: [proposal]

**Status:** AWAITING HUMAN APPROVAL
```

### ANALYST Writing Process

1. Read SPEC.md thoroughly
2. Identify module boundaries from SPEC flows
3. Map dependencies between modules
4. Draft ARCHITECTURE.md sections:
   - Module Structure
   - Layer Separation Rules
   - Interface Contracts
   - Data Flow
5. Mark uncertain decisions with `[ARCHITECTURAL DECISION NEEDED]`
6. Present to human architect for approval

**NEVER assume architectural decisions. Always propose, never dictate.**

---

## CARETAKER Instructions

**When you update ARCHITECTURE.md:**
- You've just added error handling to scaffolded code
- You notice a repeated pattern emerging
- You see opportunity to extract pattern into map-based dispatch

**What to document:**
1. New pattern introduced (if any)
2. Error handling contract at interface boundaries
3. Validation rules added

**Process:**
1. Identify the pattern you used (e.g., "Converted 3-branch if/else to map lookup")
2. Add entry to "Design Patterns in Use" section
3. Update relevant "Interface Contracts" if error handling changed
4. Write summary to `SESSION-[N]-CARETAKER-ARCHITECTURE-UPDATE.md`

**Example update:**
```markdown
## Pattern: Validation at Boundary

**Used for:** Input validation before processing

**Implementation location:** `Source/Validation/InputValidator.cpp`

**Structure:**
```cpp
// Validate at call site
if (auto error = validator.check(input))
{
    return error;  // Fail fast
}
process(input);  // Guaranteed valid
```

**Key insight:** Fail fast at boundaries, not deep in call stack.
```

---

## INSPECTOR: Architecture Documentation

### Your Responsibility
After implementation phase completes and passes user testing, audit codebase and update ARCHITECTURE.md.

### What to Document

**Module Structure:**
- New modules added
- Module responsibility changes
- Dependency graph updates

**Patterns Discovered:**
- If you see same pattern used 3+ times, document it
- If CARETAKER converted conditionals to maps, document the pattern
- If new interface contract established, document it

**Layer Contracts:**
- New API methods between layers
- Threading rules for new components
- Data flow for new features

**Design Decisions:**
- Why this implementation over alternatives
- Trade-offs accepted
- Constraints that drove design

### Analysis Process

1. **Read these in order:**
   - SPEC.md (design intent)
   - Implemented code (what exists)
   - phase-[N]-completion.md (your own audit notes)

2. **Look for:**
   - Repeated patterns (3+ occurrences)
   - Layer boundaries (who calls whom)
   - Data transformations (how data flows)
   - Error handling strategies (fail fast, graceful degradation)

3. **Ask yourself:**
   - "If I were onboarding a new agent, what patterns would they need to know?"
   - "What non-obvious contracts exist between modules?"
   - "What decisions were made that aren't visible in code?"

4. **Document:**
   - Add to appropriate ARCHITECTURE.md section
   - Use concrete examples from codebase (file:line references)
   - Explain WHY, not just WHAT

### Update Locations

**Common update sections:**
- "Design Patterns in Use" (new patterns)
- "Interface Contracts" (new APIs)
- "Data Flow" (new flows)
- "Key Design Decisions" (architectural choices)
- "Anti-Patterns Avoided" (things we explicitly rejected)

### Example Update

**Before:**
```markdown
## Design Patterns in Use

(Empty section, project just started)
```

**After Phase 2:**
```markdown
## Design Patterns in Use

### Pattern: Type-Erased Factory

**Used for:** Creating UI components from XML type strings

**Implementation location:** `Source/Registry/Registry.h:45`

**Structure:**
```cpp
ku::Function::Map<juce::String, std::unique_ptr<juce::Component>> make;
make.add("knob", []() { return std::make_unique<Knob>(); });
auto component = make.get("knob");  // Type-erased lookup
```

**Key insight:** Avoids switch statements, scales to 50+ component types.

**Call sites:**
- `Source/Manager/Manager.cpp:127` (makeAndStyle method)

**Related patterns:** See Registry System documentation for full details.
```

### When to Consult Human

**Stop and ask if:**
- Pattern seems to violate Architectural Manifesto
- Multiple viable patterns exist (you can't decide which to document)
- Architectural decision needed (e.g., "Should we extract this to library?")
- Breaking change discovered (API contract changed from SPEC)

**Example consultation:**
```
ARCHITECTURAL DECISION NEEDED

During audit, I found 5 places where we validate user input with different patterns:
1. Early return with error message (3 places)
2. Assert and crash (1 place)
3. Silent fallback to default (1 place)

Which pattern should be documented as canonical? This affects ARCHITECTURE.md.
```

---

## SURGEON: Architecture Updates During Fixes

### Your Responsibility
When fixing complex issues, you may discover existing architectural patterns or contracts that weren't documented. Update ARCHITECTURE.md to reflect reality.

### What to Document

**Discovered patterns:**
- Pattern you used that already exists in codebase
- Contract you had to follow that wasn't documented

**New patterns:**
- If your fix introduces a new pattern that solves the problem better
- Consult human first before introducing new pattern

### When to Update

**Document existing patterns:**
- If you spent >5 minutes figuring out how something works
- If the pattern isn't in ARCHITECTURE.md but should be

**Consult before new patterns:**
- If your fix requires architectural change
- If new pattern would be used by other parts of codebase

### Example Scenario

**Problem:** Status bar not updating when files staged

**Investigation reveals:**
```cpp
// Undocumented pattern: Event subscription
// Found in 3 other components, but not in ARCHITECTURE.md
events.Subscribe("files_staged", callback);
```

**SURGEON action:**
1. Fix the bug using existing pattern
2. Document pattern in ARCHITECTURE.md
3. Write `SESSION-[N]-SURGEON-PATTERN-DISCOVERED.md`

**Architecture update:**
```markdown
## Pattern: Event Subscription

**Used for:** Loose coupling between modules

**Implementation location:** `Source/Events/EventBus.cpp`

**Structure:**
```cpp
// Components subscribe to events
events.Subscribe("event_name", callback);

// Emitters publish events
events.Emit("event_name", data);
```

**Key insight:** Discovered during bug fix. Already used by StatusBar, FileList, and SidePanel.

**Call sites:**
- `Source/StatusBar/StatusBar.cpp:89`
- `Source/FileList/FileList.cpp:45`
- `Source/SidePanel/SidePanel.cpp:112`
```

---

## JOURNALIST: Architecture in Session Logs

### Your Responsibility
When compiling session logs, note any ARCHITECTURE.md updates.

### What to Include

**In session summary:**
```markdown
### Architecture Updates
- INSPECTOR documented Type-Erased Factory pattern
- SURGEON discovered Event Subscription pattern (undocumented)
- CARETAKER converted 5 switch statements to map lookups (follows Manifesto)
```

**In git commit:**
```
Session [N] complete: [Feature name]

Agents:
- Implemented: SCAFFOLDER, CARETAKER
- Inspected: INSPECTOR (updated ARCHITECTURE.md)

Architecture changes:
- Documented Type-Erased Factory pattern
- Added Interface Contract for Registry system
- Updated Module Structure with new Registry module
```

---

## ANALYST: Initial Architecture Sketch

### Your Responsibility
After user approves SPEC.md, create initial ARCHITECTURE.md skeleton.

### What to Write

**At planning stage, you provide:**
1. Module Structure (proposed boundaries)
2. Layer Separation Rules (how modules communicate)
3. Dependency Graph (who depends on whom)
4. Threading Model (if project is concurrent/real-time)

**What you DON'T write yet:**
- Design Patterns (those emerge during implementation)
- Interface Contracts (those get refined during coding)
- Anti-Patterns Avoided (we discover those through mistakes)

### Example Initial Architecture

```markdown
# [PROJECT] - Architecture

**Status:** DRAFT (Phase 1 not started)

## Module Structure

### Proposed Modules
1. **InputHandler** - Parse and validate user input
2. **CoreLogic** - Business rules and processing
3. **OutputFormatter** - Format results for display

### Proposed Dependencies
```
InputHandler → CoreLogic → OutputFormatter
(No circular dependencies)
```

## Layer Separation Rules

**InputHandler layer:**
- Validates input
- Returns errors at boundary
- Does NOT call OutputFormatter

**CoreLogic layer:**
- Pure business logic
- No I/O operations
- Returns data structures

**OutputFormatter layer:**
- Formats output
- Handles display concerns
- Does NOT modify CoreLogic data

## Threading Model

**Single-threaded:** All operations sequential (no concurrency)

---

**Note:** This is initial architecture. Will be refined after Phase 1 implementation.
```

### When to Consult Human

**Ask before writing if:**
- Multiple architectural approaches exist (monolith vs modular)
- Performance constraints unclear (real-time vs batch processing)
- Platform-specific patterns needed (JUCE, web, CLI)

**Example:**
```
ARCHITECTURAL DECISION NEEDED

SPEC calls for "file watching and auto-refresh."

Two approaches:
1. Polling every 5 seconds (simple, higher CPU)
2. OS filesystem events (complex, lower CPU)

Which should I propose in ARCHITECTURE.md?
```

---

## Cross-Role Coordination

### ANALYST → SCAFFOLDER
**ANALYST provides:**
- Module boundaries (don't cross these)
- Dependency rules (only call downward)
- Interface signatures (use these exact types)

**SCAFFOLDER uses:**
- Module Structure to organize files
- Layer Rules to know what can call what
- Dependency Graph to avoid circular refs

### SCAFFOLDER → CARETAKER
**SCAFFOLDER leaves TODOs:**
```cpp
// TODO: Add error handling (CARETAKER)
// TODO: Validate input range (CARETAKER)
// TODO: Wire to event bus per ARCHITECTURE.md (CARETAKER)
```

**CARETAKER checks ARCHITECTURE.md:**
- "What error handling pattern do we use?"
- "How do components communicate in this layer?"
- "What validation strategy is documented?"

### CARETAKER → INSPECTOR
**CARETAKER notes patterns used:**
```markdown
# SESSION-[N]-CARETAKER-SUMMARY.md

## Patterns Applied
- Converted 3 switch statements to map lookups (Manifesto compliance)
- Used Event Subscription pattern for StatusBar updates
- Added fail-fast validation at module boundary
```

**INSPECTOR documents:**
- If pattern used 3+ times → Add to ARCHITECTURE.md
- If new pattern introduced → Document with rationale
- If existing pattern → Verify consistency

### INSPECTOR → SURGEON
**INSPECTOR documents constraints:**
```markdown
## Threading Model

**UI Thread rules:**
- Can allocate memory
- Can lock briefly (<1ms)
- Cannot block on I/O

**If you violate these, audio will glitch.**
```

**SURGEON reads constraints:**
- "I must not block UI thread with network call"
- "I can use mutex but must keep lock duration <1ms"
- "I should use async pattern documented in Data Flow section"

---

## Validation Checklist

**Before considering ARCHITECTURE.md complete:**

### Completeness
- [ ] All modules in codebase are documented
- [ ] All patterns used 3+ times are documented
- [ ] All layer boundaries have contracts
- [ ] All threading rules are explicit

### Accuracy
- [ ] ARCHITECTURE.md matches current codebase (not outdated)
- [ ] Code examples compile and run
- [ ] File paths are correct (not hypothetical)
- [ ] Line numbers are current (or removed if code changed)

### Clarity
- [ ] New agent could onboard from this document
- [ ] WHY is explained, not just WHAT
- [ ] Concrete examples for every pattern
- [ ] Glossary defines project-specific terms

### Consistency
- [ ] Naming matches Coding Standards
- [ ] Patterns align with Architectural Manifesto
- [ ] No contradictions between sections

---

## Update Triggers

**ARCHITECTURE.md should be updated when:**

1. **New module added** (ANALYST or INSPECTOR)
2. **Pattern emerges** (3+ uses of same approach) (INSPECTOR)
3. **Interface contract established** (CARETAKER or INSPECTOR)
4. **Design decision made** (Human architect, documented by ANALYST)
5. **Anti-pattern avoided** (INSPECTOR after catching mistake)
6. **Threading rules change** (Human architect, documented by ANALYST)
7. **Pattern discovered during fix** (SURGEON)
8. **SPEC changes** (ANALYST updates affected sections)

---

## Red Flags: When to Stop and Consult

**Immediately consult human architect if:**

### Architectural Violations
- [ ] Layer calling upward (lower layer calling higher layer)
- [ ] Circular dependency between modules
- [ ] Direct global state access (no context passing)
- [ ] More than 2 branches in conditional (should be map)

### Pattern Inconsistencies
- [ ] Same problem solved 3 different ways
- [ ] New pattern contradicts Architectural Manifesto
- [ ] Existing pattern being violated

### Missing Constraints
- [ ] Threading rules unclear for new component
- [ ] Error handling strategy not documented
- [ ] Dependency direction ambiguous

**How to consult:**
```
ARCHITECTURE DECISION NEEDED

[Describe what you found]

[List options if multiple approaches exist]

[Ask specific question about which pattern/rule to follow]
```

---

## Success Criteria

**ARCHITECTURE.md is successful when:**

1. **New agents onboard faster** - Read doc, understand system in <30 min
2. **Fewer pattern violations** - Agents follow established patterns
3. **Clearer code reviews** - INSPECTOR can reference documented patterns
4. **Reduced rework** - Agents build correctly first time
5. **Better fixes** - SURGEON understands contracts before making changes

**Measure success by:**
- Reduction in "How does X work?" questions
- Decrease in pattern-violating code
- Faster phase completion times
- Fewer RESET contexts for SURGEON

---

## Maintenance Rules

### Continuous Updates
- Update ARCHITECTURE.md in same session as code changes
- Don't defer documentation to "later" (it never happens)
- Small, incremental updates better than big rewrites

### Version Alignment
- ARCHITECTURE.md version tracks codebase version
- If code is v1.2.3, doc should be v1.2.3
- Breaking changes increment major version

### Dead Code Removal
- When module removed, remove from ARCHITECTURE.md
- When pattern abandoned, move to "Deprecated Patterns" section
- Keep history in git, not in document

---

## Anti-Patterns in Documentation

### ❌ Vague Descriptions
```markdown
// BAD
## Module: DataHandler
Handles data.
```

```markdown
// GOOD
## Module: DataHandler
Validates user input, transforms to internal format, passes to CoreLogic.
Located: `Source/Input/DataHandler.cpp`
Depends on: Validator, Transformer
```

### ❌ Outdated Examples
```markdown
// BAD (code changed, doc didn't)
```cpp
// Example from old version (doesn't compile anymore)
```

```markdown
// GOOD
```cpp
// Current implementation as of v1.2.3
// Source/Registry/Registry.cpp:45
auto component = registry.make.get(type);
```

### ❌ Missing WHY
```markdown
// BAD
We use map-based dispatch.
```

```markdown
// GOOD
We use map-based dispatch because Architectural Manifesto requires
complex conditionals (>1 branch) to be O(1) lookups. This prevents
switch statement sprawl and makes adding new types trivial.
```

---

## Template Adaptation Guide

**This template is universal, but projects differ. Adapt by:**

### For Small Projects
- Combine sections (Module Structure + Dependency Graph in one)
- Skip Threading Model if single-threaded
- Reduce glossary if terminology is standard

### For Large Projects
- Split ARCHITECTURE.md by domain (UI/, Core/, Data/)
- Add "Module Interactions" diagrams
- Expand Threading Model with detailed rules per subsystem

### For Framework Projects
- Add "Extension Points" section (how to add plugins/modules)
- Document versioning strategy (API compatibility)
- Include migration guides between versions

### For Real-Time Projects
- Expand Threading Model with latency budgets
- Add "Performance Constraints" section
- Document lock-free patterns in detail

---

**End of Instructions**

Remember:
- ARCHITECTURE.md reflects **what exists**, not what's planned
- Update incrementally as patterns emerge
- Consult human for architectural decisions
- Code is SSOT, doc is map

**JRENG!**
